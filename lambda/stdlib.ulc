pair := ^ a b . ^p . p a b ;
first := ^ p . p (^x y . x) ;
second := ^ p . p (^x y. y) ;

(* Konstantna funkcija *)

K := ^ x y . x ;


(* Rekurzivne definicije *)

fix := ^f . (^x . f (x x)) (^x . f (x x)) ;

(* Pogojni stavki in logika *)

true  := ^x y . x ;
false := ^x y . y ;
if := ^u . u ;

and := ^x y . if x y false ;
or  := ^x y . if x true y ;
not := ^x . if x false true ;



(* Seznami *)

#var error ;

nil := ^x f . x ;

cons := ^g r . ^x f . f g r ;

head := ^l . l error (^a b . a) ;

tail := ^l . l error (^a b . b) ;

match := ^l x f. l x f ;

map := fix (^map f l . match l nil (^x xs. cons (f x) (map f xs))) ;

fold := fix (^fold x f l. match l x (^y ys . f y (fold x f ys))) ;

(* Stevila *)

0 := ^f x . x ;
1 := ^f x . f x ;
2 := ^f x . f (f x) ;
3 := ^f x . f (f (f x)) ;

succ := ^n f x . f (n f x) ;

plus := ^n m f x . (n f) ((m f) x) ;

times := ^n m f x . (n (m f)) x ;

power := ^n m . m n ;

iszero := ^n . (n (K false)) true ;

pred := ^n . second (n (^p. pair (succ (first p)) (first p)) (pair 0 error)) ;

equal := fix (^equal n m . if (iszero n) (iszero m) (equal (pred n) (pred m))) ;

fact := fix (^fact n . if (iszero n) 1 (times n (fact (pred n)))) ;
